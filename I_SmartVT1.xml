<?xml version="1.0"?>
<implementation>
	<functions>
		-- Smart Virtual Thermostat v1.0c
        
        -- ServiceID
        local TEMP_SID =    "urn:upnp-org:serviceId:TemperatureSensor1"
        local HVOS_SID =    "urn:micasaverde-com:serviceId:HVAC_OperatingState1"
        local TSH_SID =     "urn:upnp-org:serviceId:TemperatureSetpoint1_Heat"
        local TSC_SID =     "urn:upnp-org:serviceId:TemperatureSetpoint1_Cool"
        local HVUOM_SID =   "urn:upnp-org:serviceId:HVAC_UserOperatingMode1"
        local SVT_SID =     "urn:micasaverde-com:serviceId:SmartVT1"
        local SWP_SID =		"urn:upnp-org:serviceId:SwitchPower1"
		local DIM_SID =		"urn:upnp-org:serviceId:Dimming1"
		local DOOR_SID = 	"urn:micasaverde-com:serviceId:SecuritySensor1"
		local SmartVT1_id = tonumber(lul_device)
        
        -- DeviceID
        local DOOR_DID =	"urn:schemas-micasaverde-com:device:DoorSensor:1"
        local BIN_DID =     "urn:schemas-upnp-org:device:BinaryLight:1"
        local PIL_DID =     "urn:antor-fr:device:PilotWire:1"
        local DIM_DID =     "urn:schemas-upnp-org:device:DimmableLight:1"
        
		local DELAY = 20 -- Seconds
		local DEFAULT_HEAT_SP = 21
		local DEFAULT_COOL_SP = 25
		local DEFAULT_HG_SP = 8
		local constC = 0.6
		local constT = 0.01
		local interval = "1m"
		local Tinterval = 3600 -- Plage de chauffe
		local heaterStatus = "0"
		local WindowOpened = 0
		--		local startup -- Jeton permettant de savoir si l'on vient de rafraichir la Vera. Si oui, on relance le calcul.
        
		function virtual_thermostat_startup (lul_device)
            luup.log ("Smart Virtual thermostat running...")
--            startup = 1
			local data = readSettings(lul_device)
            updateStatus(lul_device)
            register_watch(data.inhibitSensors)

		end
        
		function readSettings(lul_device)
            local data = {}
        
            -- Config ID
            data.InSensors = toListOfNumbers(readVariableOrInit(lul_device,SVT_SID, "Inside Temp Sensors", "" ))
            data.OutSensors = toListOfNumbers(readVariableOrInit(lul_device,SVT_SID, "Outside Temp Sensors", "" ))
            data.inhibitSensors = toListOfNumbers(readVariableOrInit(lul_device,SVT_SID, "inhibit Sensors", "" ))
            data.heaters = toListOfNumbers(readVariableOrInit(lul_device,SVT_SID, "heaters", "" ))
			
            -- Config Variables
            data.OpenTempo = tostring(readVariableOrInit(lul_device,SVT_SID, "Waiting Time Open", "0" ))
			data.CloseTempo = tostring(readVariableOrInit(lul_device,SVT_SID, "Waiting Time Close", "0" ))
			data.ForcedTempo = tonumber(readVariableOrInit(lul_device,SVT_SID, "Forced Mode Duration", "3600" ))
			data.powerMin = tonumber(readVariableOrInit(lul_device,SVT_SID, "powerMin", "15" ))
			data.heatTimeleft = tonumber(readVariableOrInit(lul_device,SVT_SID, "heatTimeleft", "0" )) -- Temps restant en sec avant fin de chauffe
			data.calTimeleft = tonumber(readVariableOrInit(lul_device,SVT_SID, "calTimeleft", "0" )) -- Temps restant en sec avec nouveau calcul de regul


            data.heatSp = tonumber(readVariableOrInit(lul_device,TSH_SID, "CurrentSetpoint", DEFAULT_HEAT_SP ))
            data.coolSp = tonumber(readVariableOrInit(lul_device,TSC_SID, "CurrentSetpoint", DEFAULT_COOL_SP ))
        
            -- internal Variables
            data.ForcedModeState = readVariableOrInit(lul_device,SVT_SID, "Forced Mode", "ForcedOff" )
            data.EndHeatTimesStamp = tonumber(readVariableOrInit(lul_device,SVT_SID, "EndHeatTimesStamp", "0" ))
            data.TimesStamp = tonumber(readVariableOrInit(lul_device,SVT_SID, "TimesStamp", "0" ))
        
            return data
        end
		
        function AvgTemperature(t)
            local sum = 0
            local count= 0
            local temp = {}
            for k,id in pairs(t) do
                local temp = luup.variable_get(TEMP_SID, "CurrentTemperature", id)
                temp = tonumber(temp) 
                if (temp ~= nil) then
                    sum = sum + temp
                    count = count + 1
                end
            end
        
            if count &gt; 0 then
                return round((sum / count),1)
            else
                return false
            end
        
        end
        
        
        function SetTargetTable(target,t)
            for k,id in pairs(t) do
                local devicetype = luup.devices[id].device_type
                if (devicetype == BIN_DID) then
                    luup.call_action(SWP_SID, "SetTarget", { newTargetValue= target }, id)
                elseif (devicetype == PIL_DID) or (devicetype == DIM_DID)  then
                    target = tostring(tonumber(target) * 100)
                    heaterStatus = luup.variable_get(DIM_SID, "LoadLevelStatus", id) -- On recupere la variable du plugin pilotwire Antor
                    if heaterStatus ~= target then -- Si la variable du plugin pilotwire Antor est different du Target, on envoie la commande
                        luup.call_action(DIM_SID, "SetLoadLevelTarget", { newLoadlevelTarget= target}, id)
                    end
                else
                    luup.log("unknow heater device type (id :" .. id .. ")")
                end
            end
        end
		
		-- Fonction lancee si changement d'etat d'une variable watchee
		function watch_callback(lul_device, lul_service, lul_variable, lul_value_old, lul_value_new)
			local data = readSettings(SmartVT1_id)
			luup.log("Watched variable changed: " .. lul_device .. " " .. lul_service .. " " .. lul_variable .. " from " .. lul_value_old .. " to " .. lul_value_new)
			if (Inibitors(data.inhibitSensors)) then
				luup.log("Une fenetre vient de s ouvrir, il faut gerer la tempo ouverture")
				--luup.call_timer("gestionTempoOuverture", 1, tostring(data.OpenTempo), "", tostring(lul_device))
				luup.call_timer("gestionTempoOuverture", 1, data.OpenTempo, "", tostring(SmartVT1_id))
			else
				luup.log("Une fenetre vient de se fermer, il faut gerer la tempo fermeture")
				--luup.call_timer("gestionTempoOuverture", 1, tostring(data.CloseTempo), "", tostring(lul_device))
				luup.call_timer("gestionTempoFermeture", 1, data.CloseTempo, "", tostring(SmartVT1_id))
			end
		end
		
		-- Action a mener des que les variables surveillees changent d'etat
		function gestionTempoOuverture()
			local data = readSettings(lul_device)
			WindowOpened = 1
			-- On verifie que Inibitors est toujours present apres la tempo pour desactiver le chauffage
			if (Inibitors(data.inhibitSensors)) then
                luup.variable_set (HVOS_SID, "ModeState", "Idle", lul_device)
                luup.log("Inibitor detecte : arret du chauffage")
                SetTargetTable("0",data.heaters)
				updateStatus()
            else
				luup.log("Inibitor n'est plus detecte. Retour a la normale")
			end
		end
		
		function gestionTempoFermeture()
			local data = readSettings(lul_device)
			WindowOpened = 0
			-- On verifie que Inibitors est toujours absent apres la tempo pour activer le chauffage
			if not(Inibitors(data.inhibitSensors)) then
                luup.variable_set (HVOS_SID, "ModeState", "Heating", lul_device)
                luup.log("Inibitor n'est plus detecte et tempo ecoulee : reprise du chauffage")
                SetTargetTable("1",data.heaters)
				updateStatus()                
            else
				luup.log("Inibitor de nouveau detected. On ne reprend pas la regulation.")
			end
		end
				        
		function updateStatus(lul_device)
            lul_device = tonumber(lul_device)
            local data = readSettings(lul_device)
						        
            -- check data before process
--          if (data.InSensors == nil or #data.InSensors &lt; 1 or data.heaters == nil or #data.heaters &lt; 1) then
--              luup.log("Configuration erronee")
--              return nil
--          end
        
			local modeStatus = luup.variable_get(HVUOM_SID, "ModeStatus", lul_device)
        
            readTemp(lul_device,data)
			
			if (modeStatus == "HeatOn") then
				luup.variable_set (HVOS_SID, "ModeState", "Heating", lul_device)
				SetTargetTable("1",data.heaters)
			elseif (modeStatus == "CoolOn") then
				luup.variable_set (HVOS_SID, "ModeState", "Cooling", lul_device)
				SetTargetTable("1",data.Coolers)
			elseif (modeStatus == "AutoChangeOver") then
        
                --[[ Gestion des capteurs
                if (Inibitors(data.inhibitSensors)) then
                    luup.variable_set (HVOS_SID, "ModeState", "Idle", lul_device)
                    luup.log("Inibitor detecte : arret du chauffage")
                    SetTargetTable("0",data.heaters)
					luup.log("SetTargetTable 0 Inibitors")
                    luup.call_timer("updateStatus", 1, interval, "", tostring(lul_device))
                else
					luup.log("PAS DE Inibitor detecte")
				end ]]--

                -- Gestion de l'intelligence
				local tempcal = (data.TimesStamp + Tinterval)
                if ( os.time() &gt;=  (data.TimesStamp + Tinterval )) then
                    -- On relance le calcul de la regulation tous les Tinterval secondes
                    luup.log("ostime sup a " .. tempcal .. " = " .. data.TimesStamp .. "  +  " .. Tinterval)
					AutoChangeOver(lul_device)
				else
				luup.log("ostime inf a " .. tempcal .. " = " .. data.TimesStamp .. "  +  " .. Tinterval)
                end
        
        
                -- Gestion des commandes
                local ModeState = luup.variable_get (HVOS_SID, "ModeState", lul_device)
				local data = readSettings(lul_device) -- On relit les data pour charger la nouvelle valeur EndHeatTimeStamp, les timeleft...
				luup.log("os.time() = " .. os.time() .. " et data.EndHeatTimesStamp = " .. data.EndHeatTimesStamp)
				luup.log("ModeState = " .. ModeState)
				local now = os.time()
				local tempheat = data.EndHeatTimesStamp
				data.heatTimeleft = tempheat - now -- Temps restant avec fin de chauffe
				if (data.heatTimeleft &lt; 0) then data.heatTimeleft = 0 end
				data.calTimeleft = tempcal - now -- Temps restant avec nouveau calcul de regulation
				
				luup.log("Temps de chauffe restant : " .. data.heatTimeleft .. " et temps restant avec nouveau calcul : " .. data.calTimeleft) 
				luup.variable_set (SVT_SID, "heatTimeleft", data.heatTimeleft, lul_device)
				luup.variable_set (SVT_SID, "calTimeleft", data.calTimeleft, lul_device)
				
                if (ModeState == "Heating") then
                    if( os.time() &gt;= data.EndHeatTimesStamp ) then
                        SetTargetTable("0",data.heaters)
						luup.log("HEATER OFF")
                    else
                        SetTargetTable("1",data.heaters)
						luup.log("HEATER ON")
                    end
                elseif(ModeState == "Cooling") then
                    -- a completer
                else
                    SetTargetTable("0",data.heaters)
                end

			else
				luup.variable_set (HVUOM_SID, "ModeStatus", "Off", lul_device)
				luup.variable_set (HVOS_SID, "ModeState", "Idle", lul_device)
				luup.log("La puissance de chauffe est de: 0 ")
                SetTargetTable("0",data.heaters)
--				SetTargetTable("0",data.Coolers)
			end
        
			luup.call_timer("updateStatus", 1, interval, "", tostring(lul_device))
		end
        
        function readTemp(lul_device,data)
        
            local Tint = AvgTemperature(data.InSensors) or data.heatSp
            luup.log("La temperature moyenne interieure est de " .. Tint .. " DEGC")
            luup.variable_set (TEMP_SID, "CurrentTemperature", Tint, lul_device)
        
            local Text = AvgTemperature(data.OutSensors) or data.heatSp
            luup.log("La temperature moyenne exterieure est de " .. Text .. " DEGC")
            --luup.variable_set (TEMP_SID, "CurrentTemperature", Text, lul_device)
        
            return Tint,Text
        end
		
        function Inibitors(Sensors)
            for index = 1, #Sensors, 1 do
                local device = Sensors[index]
				local inhibitor
				local lastSet
				
				local invert = false
                if (0 > device) then
                    device = 0 - device
                    invert = true
				end
        
                local type_device = luup.devices[device].device_type -- On determine le SID en fonction de l'ID.
				
				if type_device == DOOR_DID then -- En fonction du SID, on determine la variable a lire. A ameliorer peut etre.
					inhibitor, lastSet = luup.variable_get(DOOR_SID, "Tripped", device)
					luup.log("inhibitor DOOR = " .. inhibitor)
				elseif type_device == BIN_DID then
					inhibitor, lastSet = luup.variable_get(SWP_SID, "Status", device)
					luup.log("inhibitor SWP = " .. inhibitor)
				end
								
                if (inhibitor == (invert and "0" or "1")) then
			        return true
				end
            end
            return false
        end 
		
        function AutoChangeOver(lul_device)
        
            local data = readSettings(lul_device)

            local Tint, Text = readTemp(lul_device,data)
        
            --if (Tint &lt; data.heatSp) then
                local power = ((data.heatSp - Tint) * constC + (data.heatSp - Text) * constT) * 100
                if (power &lt; 0) then power = 0 end -- Limite basse
                if (power &gt; 100) then power = 100 end -- Limite haute
				if (power &gt; 0) and (power &lt;= data.powerMin) then power = data.powerMin end -- Seuil mini de power
                local tpschauf = power * (Tinterval/100)
                tpschauf = math.floor(tpschauf)
                local calnow = os.time()
                --local hchauf = os.time(calnow + tpschauf)
                hchauf = GetTime(calnow,tpschauf) -- Needed to works with Vera 1 (single-precision floats)
        
                luup.log("La puissance calculee est de : " .. power .. "% et le temps de chauffe est de : " .. (tpschauf/60) .. " minutes sur " .. (Tinterval/60) .. " minutes")
                luup.log("Puissance calculee a: " .. calnow .. ". Le chauffage s'arretera a : " .. hchauf)
       
			if WindowOpened == 0 then
                luup.variable_set (SVT_SID, "TimesStamp", calnow, lul_device)
                luup.variable_set (SVT_SID, "EndHeatTimesStamp", hchauf, lul_device)
                luup.variable_set (HVOS_SID, "ModeState", "Heating", lul_device)
				luup.log("WindowOpened = " .. WindowOpened)
			else
				luup.log("Une des fenetres ouverte empeche la reprise du chauffage. WindowOpened = " .. WindowOpened)
			end
				
                
            --else
            --   luup.variable_set (HVOS_SID, "ModeState", "Idle", lul_device)
            --end
        end

        
        
	</functions>
	<startup>virtual_thermostat_startup</startup>
    <files>L_SmartVT1.lua</files>
	<actionList>
		<action>
			<serviceId>urn:micasaverde-com:serviceId:SmartVT1</serviceId>
			<name>SetForcedMode</name>
			<job>
				luup.variable_set (SVT_SID, "Forced Mode", lul_settings.NewForcedMode, lul_device)
				-- Action to do
				return 4, 5
			</job>
		</action>
		<action>
			<serviceId>urn:upnp-org:serviceId:HVAC_UserOperatingMode1</serviceId>
			<name>SetEnergyModeTarget</name>
			<job>
				luup.variable_set (HVUOM_SID, "EnergyModeTarget", lul_settings.NewEnergyModeTarget, lul_device)
				luup.variable_set (HVUOM_SID, "EnergyModeStatus", lul_settings.NewEnergyModeTarget, lul_device)
				AutoChangeOver(lul_device)
                updateStatus(lul_device)
				return 4, 5
			</job>
		</action>
		<action>
			<serviceId>urn:upnp-org:serviceId:HVAC_UserOperatingMode1</serviceId>
			<name>SetModeTarget</name>
			<job>
				luup.variable_set (HVUOM_SID, "ModeTarget", lul_settings.NewModeTarget, lul_device)
				luup.variable_set (HVUOM_SID, "ModeStatus", lul_settings.NewModeTarget, lul_device)
				AutoChangeOver(lul_device)
                updateStatus(lul_device)
				return 4, 5
			</job>
		</action>
		<action>
			<serviceId>urn:upnp-org:serviceId:TemperatureSetpoint1_Heat</serviceId>
			<name>SetCurrentSetpoint</name>
			<job>
			-- On conditionne le lancement des fonctions au mode selectionne pour ne pas recalculer le coef quand on est dans lautre mode
				luup.variable_set (TSH_SID, "CurrentSetpoint", lul_settings.NewCurrentSetpoint, lul_device)
				local EnergyModeStatus = luup.variable_get (HVUOM_SID, "EnergyModeStatus", lul_device)
                local modeStatus = luup.variable_get (HVUOM_SID, "ModeStatus", lul_device)
				if (modeStatus == "AutoChangeOver") and (EnergyModeStatus == "Normal") then
                    AutoChangeOver(lul_device)
					updateStatus(lul_device)
                end
				return 4, 5
			</job>
		</action>
		<action>
			<serviceId>urn:upnp-org:serviceId:TemperatureSetpoint1_Cool</serviceId>
			<name>SetCurrentSetpoint</name>
			<job>
			-- On conditionne le lancement des fonctions au mode selectionne pour ne pas recalculer le coef quand on est dans lautre mode
				luup.variable_set (TSC_SID, "CurrentSetpoint", lul_settings.NewCurrentSetpoint, lul_device)
				local EnergyModeStatus = luup.variable_get (HVUOM_SID, "EnergyModeStatus", lul_device)
                local modeStatus = luup.variable_get (HVUOM_SID, "ModeStatus", lul_device)
				if (modeStatus == "AutoChangeOver") and (EnergyModeStatus == "EnergySavingsMode") then
                    AutoChangeOver(lul_device)
					updateStatus(lul_device)
                end
				return 4, 5
			</job>
		</action>
		<action>
			<serviceId>urn:upnp-org:serviceId:SwitchPower1</serviceId>
			<name>SetTarget</name>
			<job>
				luup.variable_set (SWP_SID, "Target", lul_settings.newTargetValue, lul_device)
				luup.variable_set (SWP_SID, "Status", lul_settings.newTargetValue, lul_device)
				return 4, 5
			</job>
		</action>
	</actionList>
</implementation>
